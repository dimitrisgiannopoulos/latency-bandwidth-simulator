<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball Game</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: auto;
        }
        #startGame {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            font-size: 16px;
        }
        #controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        #leftButton, #rightButton {
            padding: 10px 20px;
            font-size: 16px;
        }
        #latency {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
    
        #payloadControl {
            text-align: center;
            margin-bottom: 20px;
            margin-top: 20px;
        }
        #payloadSize {
            margin: 10px 0;
        }
        #payloadLabel {
            font-weight: bold;
            font-size: 1.2em;
            display: inline-block;
            width: 80px;
        }
    </style>
</head>
<body>
    <button id="startGame">Start Game</button>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <div id="latency">Latency: - ms</div>
    <div id="payloadControl">
        <label for="payloadSize">Payload Size:</label>
        <input type="range" id="payloadSize" min="0" max="3" step="1" value="0">
        <span id="payloadLabel">No Padding</span>
    </div>
    <div id="controls">
        <button id="leftButton">Left</button>
        <button id="rightButton">Right</button>
    </div>    

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startGame');
        const latencyDisplay = document.getElementById('latency');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const payloadSizeSlider = document.getElementById('payloadSize');
        const payloadLabel = document.getElementById('payloadLabel');
        const paddingLevels = {
            NoPadding: 0,          // No padding
            Light: 50 * 1024,     // 50 KB
            Medium: 100 * 1024,    // 100 KB
            Heavy: 250 * 1024     // 250 KB
        };
        const paddingCache = {
            NoPadding: '',
            Light: 'X'.repeat(paddingLevels.Light),
            Medium: 'X'.repeat(paddingLevels.Medium),
            Heavy: 'X'.repeat(paddingLevels.Heavy),
        };
        const serverUrl = `${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${window.location.host}`;
        let selectedPayloadSize = 'NoPadding'; 
        let ws = null;
        let gameState = {
            ball: { x: 250, y: 250 },
            paddle: { x: 200, width: 100 },
            score: 0,
            gameOver: false,
        };

        // WebSocket connection
        function connectWebSocket(callback) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                callback();
                return;
            }
        
            ws = new WebSocket(serverUrl);
            
            ws.onopen = () => {
                console.log("WebSocket connection established with", serverUrl);
                measureLatency();
                ws.send(JSON.stringify({ type: 'updatePadding', level: selectedPayloadSize }));
                if (callback) callback();
            };
        
            ws.onmessage = (event) => {
                const message = event.data;
            
                // Skip padding messages
                if (typeof message === 'string' && message.startsWith('PADDING:')) {
                    return;
                }
            
                // Process game state and other prefixed messages
                if (message.startsWith('DATA:')) {
                    try {
                        const data = JSON.parse(message.slice(5)); // Remove `DATA:` prefix and parse
                        if (data.type === 'gameState') {
                            gameState = data.gameState;
                        } else if (data.type === 'gameOver') {
                            alert(`Game Over! Your score: ${data.score}`);
                        }
                    } catch (err) {
                        console.error('Error parsing DATA message:', err);
                    }
                    return;
                }
            
                // Handle JSON messages like pong or errors
                try {
                    const data = JSON.parse(message);
                    if (data.type === 'pong') {
                        const latency = Date.now() - data.time;
                        updateLatencyDisplay(latency);
                    } else {
                        console.warn('Unknown JSON message received:', data);
                    }
                } catch (err) {
                    console.error('Unknown message format:', message);
                }
            };            
        
            ws.onclose = () => {
                console.log('WebSocket connection closed.');
            };
        
            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };
        }
    
        function measureLatency() {
            setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const pingTime = Date.now();
                    ws.send(JSON.stringify({ type: 'ping', time: pingTime }));
                }
            }, 1000);
        }
    
        function updateLatencyDisplay(latency) {
            latencyDisplay.textContent = `Latency: ${latency} ms`;
            latencyDisplay.style.color = latency <= 50 ? 'green' : latency <= 150 ? 'orange' : 'red';
        }
    
        payloadSizeSlider.addEventListener('input', () => {
            const levels = ['No Padding', 'Light', 'Medium', 'Heavy'];
            selectedPayloadSize = levels[payloadSizeSlider.value];
            payloadLabel.textContent = selectedPayloadSize;
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'updatePadding', level: selectedPayloadSize }));
            }
        });

        function movePaddle(direction) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = { type: 'paddleMove', direction: direction === 'left' ? -1 : 1 };
                ws.send(`DATA:${JSON.stringify(message)}`);
                if (paddingLevels[selectedPayloadSize] > 0) {
                    ws.send(`PADDING:${paddingCache[selectedPaddingLevel]}`);
                }
            }
        }

        leftButton.addEventListener('click', () => movePaddle('left'));
        rightButton.addEventListener('click', () => movePaddle('right'));
    
        // Event listeners for keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') movePaddle('left');
            if (e.key === 'ArrowRight') movePaddle('right');
        });
    
        // Start the game
        startButton.addEventListener('click', () => {
            connectWebSocket(() => ws.send(`DATA:${JSON.stringify({ type: 'startGame' })}`));
        });
    
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'blue';
            ctx.fill();
            ctx.closePath();
            ctx.fillStyle = 'black';
            ctx.fillRect(gameState.paddle.x, 480, gameState.paddle.width, 10);
            ctx.font = '16px Arial';
            ctx.fillText(`Score: ${gameState.score}`, 10, 20);
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>
