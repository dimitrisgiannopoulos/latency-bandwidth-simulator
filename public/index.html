<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball Game</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: auto;
        }
        #startGame {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            font-size: 16px;
        }
        #controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        #leftButton, #rightButton {
            padding: 10px 20px;
            font-size: 16px;
        }
        #latency {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
    
        #payloadControl {
            text-align: center;
            margin-bottom: 20px;
            margin-top: 20px;
        }
        #payloadSize {
            margin: 10px 0;
        }
        #payloadLabel {
            font-weight: bold;
            font-size: 1.2em;
            display: inline-block; /* Prevent shifting by reserving space */
            width: 80px; /* Fixed width to accommodate all labels */
        }
    </style>
</head>
<body>
    <button id="startGame">Start Game</button>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <div id="latency">Latency: - ms</div>
    <div id="payloadControl">
        <label for="payloadSize">Payload Size:</label>
        <input type="range" id="payloadSize" min="1" max="3" step="1" value="1">
        <span id="payloadLabel">Light</span>
    </div>
    <div id="controls">
        <button id="leftButton">Left</button>
        <button id="rightButton">Right</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startGame');
        const latencyDisplay = document.getElementById('latency');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const payloadSizeSlider = document.getElementById('payloadSize');
        const payloadLabel = document.getElementById('payloadLabel');
        const paddingLevels = {
            Light: 100 * 1024,  // 100 KB
            Medium: 500 * 1024, // 500 KB
            Heavy: 1024 * 1024  // 1 MB
        };
        let selectedPayloadSize = 'Light'; // Match the initial slider value
        let payloadPadding = 'X'.repeat(paddingLevels[selectedPayloadSize]); // Initialize padding based on the default size
        let ws = null;
        let gameState = {
            ball: { x: 250, y: 250 },
            paddle: { x: 200, width: 100 },
            score: 0,
            gameOver: false,
        };
    
        // WebSocket connection
        function connectWebSocket(callback) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                callback();
                return;
            }
        
            ws = new WebSocket('ws://localhost:3000');
        
            ws.onopen = () => {
                console.log('WebSocket connection established.');
                measureLatency();
        
                // Send the initial padding level to the server
                ws.send(JSON.stringify({ type: 'updatePadding', level: selectedPayloadSize }));
                console.log(`Initial padding level sent to server: ${selectedPayloadSize}`);
        
                if (callback) callback(); // Start game after connection
            };
        
            ws.onmessage = (event) => {
                let data;
            
                try {
                    data = JSON.parse(event.data);
                } catch (err) {
                    console.error("Invalid JSON received:", event.data);
                    return;
                }
            
                // Check if `data.message` is a string and parse it only if necessary
                if (typeof data.message === 'string') {
                    try {
                        data.message = JSON.parse(data.message);
                    } catch (err) {
                        console.error("Invalid JSON in 'message':", data.message);
                        return;
                    }
                }
            
                console.log('Received message:', data);
            
                if (data.message?.type === 'gameState') {
                    gameState = data.message.gameState; // Update the game state
                } else if (data.message?.type === 'pong') {
                    const latency = Date.now() - data.message.time;
                    updateLatencyDisplay(latency);
                } else if (data.message?.type === 'gameOver') {
                    alert(`Game Over! Your score: ${data.message.score}`);
                }
            };             
        
            ws.onclose = () => {
                console.log('WebSocket connection closed.');
            };
        
            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };
        }        
    
        // Measure latency
        function measureLatency() {
            setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const pingTime = Date.now();
                    ws.send(JSON.stringify({ type: 'ping', time: pingTime }));
                }
            }, 1000);
        }
    
        // Update latency display
        function updateLatencyDisplay(latency) {
            latencyDisplay.textContent = `Latency: ${latency} ms`;
            if (latency <= 50) {
                latencyDisplay.style.color = 'green';
            } else if (latency <= 150) {
                latencyDisplay.style.color = 'yellow';
            } else {
                latencyDisplay.style.color = 'red';
            }
        }
    
        // Update the label and padding size based on the slider
        payloadSizeSlider.addEventListener('input', () => {
            switch (payloadSizeSlider.value) {
                case '1':
                    payloadLabel.textContent = 'Light';
                    selectedPayloadSize = 'Light';
                    break;
                case '2':
                    payloadLabel.textContent = 'Medium';
                    selectedPayloadSize = 'Medium';
                    break;
                case '3':
                    payloadLabel.textContent = 'Heavy';
                    selectedPayloadSize = 'Heavy';
                    break;
            }

            // Send the updated padding level to the server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'updatePadding', level: selectedPayloadSize }));
            }
        });

        // Paddle movement
        function movePaddle(direction) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const paddleDirection = direction === 'left' ? -1 : 1; // -1 for left, 1 for right
                const originalMessage = JSON.stringify({ type: 'paddleMove', direction: paddleDirection });
        
                const payloadSize = paddingLevels[selectedPayloadSize];
                const paddedMessage = createPaddedMessage(originalMessage, payloadSize);
        
                // Send the padded movement message to the server
                ws.send(paddedMessage);
            }
        }        
    
        // Function to generate a padded message
        function createPaddedMessage(originalMessage, sizeInBytes) {
            const paddingLength = Math.max(0, sizeInBytes - originalMessage.length);
            const padding = 'X'.repeat(paddingLength); // Fill the remaining space with "X"
        
            // Add padding directly to the original message object
            const paddedMessageObject = JSON.parse(originalMessage);
            paddedMessageObject.padding = padding; // Add padding as a separate field
        
            return JSON.stringify(paddedMessageObject); // Return the padded message as JSON
        }

        // Attach event listeners for on-screen buttons
        leftButton.addEventListener('click', () => movePaddle('left'));
        rightButton.addEventListener('click', () => movePaddle('right'));
    
        // Event listeners for keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') movePaddle('left');
            if (e.key === 'ArrowRight') movePaddle('right');
        });
    
        // Start the game
        startButton.addEventListener('click', () => {
            connectWebSocket(() => {
                console.log('Sending startGame request to server.');
                ws.send(JSON.stringify({ type: 'startGame' }));
            });
        });
    
        // Render the game
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
    
            // Draw the ball
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'blue';
            ctx.fill();
            ctx.closePath();
    
            // Draw the paddle
            ctx.fillStyle = 'black';
            ctx.fillRect(gameState.paddle.x, 480, gameState.paddle.width, 10);
    
            // Draw the score
            ctx.font = '16px Arial';
            ctx.fillText(`Score: ${gameState.score}`, 10, 20);
    
            requestAnimationFrame(render);
        }
    
        render();
    </script>     
</body>
</html>
